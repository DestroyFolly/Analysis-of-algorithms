\chapter{Исследовательская часть}

В данном разделе будут приведены примеры работы программа, а также проведен сравнительный анализ алгоритмов при различных ситуациях на основе полученных данных.

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялось тестирование представлены далее:

\begin{itemize}
	\item операционная система: Windows 10 Pro;
	\item память: 32 ГБ;
	\item процессор: 12th Gen Intel(R) Core(TM) i5-12400   2.50 ГГц \cite{intel}.
\end{itemize}

Во время тестирования компьютер был нагружен только встроенными приложениями окружения, а также системой тестирования.

\section{Демонстрация работы программы}

На рисунке \ref{img:prog} представлен результат работы программы.

\imgHeight{90mm}{prog}{Пример работы программы}
\clearpage

\section{Время выполнения алгоритмов}

Как было сказано выше, используется функция замера процессорного времени process\_time(...) из библиотеки time на Python. Функция возвращает пользовательское процессорное время типа float.

Использовать функцию приходится дважды, из времени завершения необходимо вычесть время начала работы функции, чтобы получить результат.

Замеры проводились для длины слова от 0 до 9 по 100 раз на различных входных данных.

Результаты замеров приведены в таблице \ref{tbl:time_mes} (время в мс).

\begin{table}[h]
	\begin{center}
		\begin{threeparttable}
			\captionsetup{justification=raggedright,singlelinecheck=off}
			\caption{Результаты замеров времени}
			\label{tbl:time_mes}
			\begin{tabular}{|c|c|c|c|c|}
				\hline
				Длина & Л.(рек) & Л.(матр.)& Л.(рек с матр.) & Д.-Л.(рек.)  \\
				\hline
				0 & 0.0023 & 0.0038 & 0.0075 & 0.0028 \\ 
				\hline
				1 & 0.0074 & 0.0110 & 0.0122 & 0.0088 \\ 
				\hline
				2 & 0.0362 & 0.0122 & 0.0125 & 0.0295 \\ 
				\hline
				3 & 0.0535 & 0.0104 & 0.0132 & 0.0575 \\ 
				\hline
				4 & 0.5422 & 0.0136 & 0.0210 & 0.9562 \\ 
				\hline
				5 & 0.9125 & 0.0175 & 0.0292 & 1.5250 \\ 
				\hline
				6 & 1.3875 & 0.0228 & 0.0388 & 2.7580 \\ 
				\hline
				7 & 12.3438 & 0.0354 & 0.0544 & 21.4985 \\ 
				\hline
				8 & 69.3750 & 0.0548 & 0.0618 & 126.4228 \\ 
				\hline
				9 & 378.2812 & 0.0604 & 0.0834 & 723.4395 \\ 
				\hline
			\end{tabular}
		\end{threeparttable}
	\end{center}
\end{table}
Где Л – реализация алгоритма Левенштейна, а Д.-Л. – реализация алгоритма Дамерау-Левенштейна.
\clearpage

Также на рисунках \ref{img:graph_lev_rec_and_cache}, \ref{img:graph_lev_mat_and_cache}, \ref{img:graph_lev_and_dam_lev} приведены графические результаты замеров.

\imgHeight{100mm}{graph_lev_rec_and_cache}{Сравнение по времени алгоритмов Левенштейна с использованием рекурсии и с использованием кеша (матрица + рекурсия)}
\imgHeight{100mm}{graph_lev_mat_and_cache}{Сравнение алгоритмов нахождения расстояния Левенштейна матричного и с кешем в виде матрицы}
\imgHeight{100mm}{graph_lev_and_dam_lev}{Сравнение по времени рекурсивных алгоритмов Левенштейна и Дамерау-Левенштейна}
\clearpage


\section{Вывод}

Исходя из замеров по памяти, итеративные алгоритмы проигрывают рекурсивным, потому что максимальный размер памяти в них растет, как произведение длин строк, а в рекурсивных - как сумма длин строк.

В результате эксперимента было получено, что при длине строк в более 5 символов, алгоритм Левенштейна быстрее Дамерау-Левенштейна в 2 раза. В итоге, можно сказать, что при таких данных следует использовать алгоритм Левенштейна.

Также при проведении эксперимента было выявлено, что на длине строк в 4 символа рекурсивная реализация алгоритма Левенштейна в уже в 14 раз медленнее матричной реализации алгоритма. При увеличении длины строк в геометрической прогрессии растет и время работы рекурсивной реализации. Следовательно, стоит использовать матричную реализацию для строк длиной более 4 символов.
